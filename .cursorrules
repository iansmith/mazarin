# Cursor AI Project Rules for Mazarin Kernel

This file contains architectural rules and patterns that must be followed for all code changes in this project.

## Core Principles

1. **No CGO** - This is a bare-metal kernel. Use `//go:linkname` to connect Go and assembly.
2. **Always use `//go:nosplit`** - Required for all functions that call assembly or do MMIO.
3. **32-bit flags** - Use `uint32` for packed bitfields (works on both 32-bit and 64-bit processors).
4. **Code generation** - Bitfield code must be regenerated before building (run `make generate`).

## Go + Assembly Integration

- Use `//go:linkname` to link Go functions to assembly symbols
- Assembly functions must be `//go:nosplit`
- Go functions called from assembly need `//go:noinline` and symbol promotion via `objcopy`
- Use `uintptr` for memory addresses (correct size on 64-bit)

## Bitfield Management

- Define structs with `bitfield` tags: `bitfield:",bits"`
- Always use 32 bits for flags (`uint32`, not `uint64`)
- Generated code is in `bitfield/*_gen.go` - never edit directly
- Run `make generate` to regenerate after changing bitfield structs

## Memory Management

- Kernel entry point: `0x200000` (64-bit Raspberry Pi 4)
- Stack pointer: `0x400000` (above kernel)
- Page size: 4KB (4096 bytes)
- Reserve pages from `0x200000` to `__end` as kernel pages
- Use `//go:linkname` to access linker symbols like `__end`

## Build Process

- Code generation runs automatically before compilation
- Use `GOTOOLCHAIN=local` for code generation
- Use `GOTOOLCHAIN=auto GOARCH=arm64 GOOS=linux` for kernel compilation
- Always run `make test` before committing

## Assembly Conventions

- AArch64 calling convention: parameters in `x0, x1, x2...` (64-bit) or `w0, w1, w2...` (32-bit)
- Return values in `x0`/`w0`
- Use `.global` for exported assembly functions
- Use `.extern` for Go functions called from assembly

## MMIO Access

- All MMIO through assembly functions (`mmio_write`, `mmio_read`)
- Raspberry Pi 4 base: `PERIPHERAL_BASE = 0xFE000000`
- Use `uintptr` for addresses, `uint32` for data

## CPU Initialization

- Only CPU 0 runs kernel code
- Other CPUs (1-3) halt in tight loop with `wfe`
- Check CPU ID in boot code before initialization

## Testing

- Run `make test` to verify bitfield functionality
- All tests must pass before committing
- Tests run on host (not in QEMU)

## File Organization

The project uses a clean separation between Go code, assembly code, and build artifacts:

```
src/
├── asm/              # Assembly source files
│   ├── boot.s        # CPU init, BSS clearing, entry point
│   └── lib.s         # Assembly utilities (MMIO, delays, bzero)
├── go/
│   └── mazarin/      # Go kernel package
│       ├── kernel.go # Main kernel logic, UART functions
│       ├── page.go   # Page management (4KB pages)
│       └── heap.go   # Dynamic memory allocator (kmalloc/kfree)
├── bitfield/         # Bitfield code generation
│   ├── page_flags.go # PageFlags struct definition
│   ├── gen.go        # Code generator
│   └── *_gen.go      # Generated files (never edit directly)
├── go.mod            # Go module definition
├── linker.ld         # Memory layout and linker script
└── Makefile          # Build configuration
```

**Key points:**
- Go code is in `go/mazarin/` package (clean separation from assembly)
- Assembly files are in `asm/` directory
- Build artifacts (`.o`, `.elf`) are created in `src/` root
- The Makefile builds Go package from `go/mazarin/` and assembly from `asm/`

## Docker and QEMU Testing

The `docker/` directory contains scripts and configuration for testing the kernel in QEMU:

```
docker/
├── Dockerfile         # Alpine Linux container with QEMU for Raspberry Pi 4 emulation
├── runqemu            # Run kernel normally in QEMU (for testing)
├── runqemu-debug      # Run QEMU with GDB server enabled (for debugging)
├── runqemu-trace      # Run QEMU with instruction tracing (for analysis)
└── builtin/           # Kernel artifacts (kernel.elf copied here via `make push`)
```

**Purpose:**
- **Dockerfile**: Creates a reproducible QEMU environment for testing the bare-metal kernel
  - Based on Alpine Linux 3.22
  - Includes QEMU system emulator for AArch64 (Raspberry Pi 4)
  - Mounts `docker/builtin/` as readonly to load kernel.elf
  
- **runqemu**: Standard testing script
  - Runs the kernel in QEMU emulating Raspberry Pi 4B
  - Redirects UART output to stdout (headless mode)
  - Useful for normal testing and development
  
- **runqemu-debug**: GDB debugging script
  - Enables GDB server on port 1234 (configurable via `GDB_PORT`)
  - Pauses execution at startup, waiting for GDB to connect
  - Connect with: `target-gdb kernel.elf`, then `(gdb) target remote localhost:1234`
  
- **runqemu-trace**: Instruction tracing script
  - Shows instruction addresses as they execute
  - Useful for understanding execution flow
  - Filters to show only CPU 0 traces (other CPUs halt)

**Workflow:**
1. Build kernel: `cd src && make` → creates `kernel.elf`
2. Copy to docker: `cd src && make push` → copies `kernel.elf` to `docker/builtin/`
3. Run in QEMU: `docker/runqemu` (or debug/trace variants)

## When Making Changes

1. If changing bitfield structs: run `make generate` first
2. If adding assembly functions: ensure `.global` and proper calling convention
3. If adding Go functions called from assembly: add `//go:nosplit` and `//go:noinline`
4. If accessing linker symbols: use `//go:linkname`
5. Always run `make test` before committing

See `ARCHITECTURE.md` for detailed explanations of these patterns.

