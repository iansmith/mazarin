# Cursor AI Project Rules for Mazarin Kernel

This file contains architectural rules and patterns that must be followed for all code changes in this project.

## Core Principles

1. **No CGO** - This is a bare-metal kernel. Use `//go:linkname` to connect Go and assembly.
2. **Always use `//go:nosplit`** - Required for all functions that call assembly or do MMIO.
3. **32-bit flags** - Use `uint32` for packed bitfields (works on both 32-bit and 64-bit processors).
4. **Code generation** - Bitfield code must be regenerated before building (run `make generate`).
5. **Prefer Go over Assembly** - Implement logic in Go whenever possible. Assembly should be reserved for:
   - Specific CPU instructions not available in Go (system register access, barriers, etc.)
   - Exception vector tables and initial exception entry/exit
   - Small, focused operations that must execute without a stack frame
   - Assembly should NOT contain complex logic, branching, or dispatch - delegate to Go functions instead
6. **Minimal Assembly Functions** - Keep assembly functions small and single-purpose. Complex interrupt handling, routing, and dispatch should be done in Go where debugging is easier.

## Go + Assembly Integration

- Use `//go:linkname` to link Go functions to assembly symbols
- Assembly functions must be `//go:nosplit`
- Go functions called from assembly need `//go:noinline` and symbol promotion via `objcopy`
- Use `uintptr` for memory addresses (correct size on 64-bit)

## Bitfield Management

- Define structs with `bitfield` tags: `bitfield:",bits"`
- Always use 32 bits for flags (`uint32`, not `uint64`)
- Generated code is in `bitfield/*_gen.go` - never edit directly
- Run `make generate` to regenerate after changing bitfield structs

## Memory Management

### Raspberry Pi 4 (Real Hardware)
- RAM starts at: `0x00000000`
- Kernel entry point: `0x200000`
- Stack pointer: `0x400000` (above kernel)
- BSS section: After kernel code (e.g., `0x32f000`)
- Heap: After BSS (e.g., `0x500000`)

### QEMU virt Machine
- **ROM region**: `0x00000000 - 0x08000000` (kernel loaded at `0x200000`)
- **UART**: `0x09000000` (PL011)
- **RAM region**: `0x40000000 - end` (writable memory!)
- Stack pointer: `0x40400000` (4MB into RAM)
- BSS section: `0x40000000` (start of RAM)
- Heap: `0x40500000` (5MB into RAM)

**Critical**: QEMU virt machine has separate ROM and RAM regions! The kernel code loads in ROM at 0x200000, but all writable data (BSS, stack, heap) must be in RAM starting at 0x40000000.

### General
- Page size: 4KB (4096 bytes)
- Use `//go:linkname` to access linker symbols like `__end`

## Build Process

- Code generation runs automatically before compilation
- Use `GOTOOLCHAIN=local` for code generation
- Use `GOTOOLCHAIN=auto GOARCH=arm64 GOOS=linux` for kernel compilation
- Always run `make test` before committing

## Quick Build/Run (local QEMU)

- Build: `cd src && make mazboot` (builds mazboot into the build directory)
- Run: `runmazboot` (requires environment script to be sourced first)
  - Normal mode: `mazboot` (Cocoa display window, UART output in terminal)
  - Terminal-only: `NOGRAPHIC=1 mazboot` (no GUI window)
  - Separate logs: `SEPARATE_OUTPUT=1 mazboot` (kernel output → kernel-uart.log, QEMU debug → qemu-debug.log)

## Cross-Compiler Tooling

- Cross-compiler tools use the `target-` prefix instead of the full `aarch64-none-elf-` prefix
- Tools are located in `bin/` directory (relative to project root)
- To access tools, source the environment script: `source enable-mazzy` (or `source /Users/iansmith/mazzy/enable-mazzy`)
- Examples: `target-gcc`, `target-objdump`, `target-readelf`, `target-gdb`, etc.
- The `target-` prefix is a symlink to the full `aarch64-none-elf-` prefixed binaries

## Environment Setup

**Always source the environment script before using tools or scripts:**

```bash
source /Users/iansmith/mazzy/enable-mazzy
# or from project root:
source enable-mazzy
```

This script adds the `bin/` directory to PATH, making available:
- Cross-compiler tools (`target-gcc`, `target-objdump`, `target-readelf`, `target-gdb`, etc.)
- QEMU scripts (`runqemu-fb`, `runqemu-debug`, `runqemu-trace`, `mazboot`, etc.)
- Utility tools (`timeout`, etc.)

**What the environment script does:**
- Sets `PATH=/Users/iansmith/mazzy/bin:$PATH` to make tools available
- The `bin/` directory contains symlinks to cross-compiler tools with `target-` prefix
- Example: `target-gcc` → `/Users/iansmith/mazzy/aarch64-none-elf/bin/aarch64-none-elf-gcc`

**Important:** 
- The QEMU scripts (`runqemu-fb`, `mazboot`, etc.) require the environment to be sourced to work correctly
- The `mazboot` script runs QEMU locally (not in Docker) with Cocoa display for macOS
- Always source the environment script in each new terminal session before building or running tests

## Assembly Conventions

- AArch64 calling convention: parameters in `x0, x1, x2...` (64-bit) or `w0, w1, w2...` (32-bit)
- Return values in `x0`/`w0`
- Use `.global` for exported assembly functions
- Use `.extern` for Go functions called from assembly

## MMIO Access

- All MMIO through assembly functions (`mmio_write`, `mmio_read`)
- Raspberry Pi 4 base: `PERIPHERAL_BASE = 0xFE000000`
- Use `uintptr` for addresses, `uint32` for data

## CPU Initialization

- Only CPU 0 runs kernel code
- Other CPUs (1-3) halt in tight loop with `wfe`
- Check CPU ID in boot code before initialization

## Testing

- Run `make test` to verify bitfield functionality
- All tests must pass before committing
- Tests run on host (not in QEMU)

## File Organization

The project uses a clean separation between Go code, assembly code, and build artifacts:

```
src/
├── asm/              # Assembly source files
│   ├── boot.s        # CPU init, BSS clearing, entry point
│   └── lib.s         # Assembly utilities (MMIO, delays, bzero)
├── go/
│   └── mazarin/      # Go kernel package
│       ├── kernel.go # Main kernel logic, UART functions
│       ├── page.go   # Page management (4KB pages)
│       └── heap.go   # Dynamic memory allocator (kmalloc/kfree)
├── bitfield/         # Bitfield code generation
│   ├── page_flags.go # PageFlags struct definition
│   ├── gen.go        # Code generator
│   └── *_gen.go      # Generated files (never edit directly)
├── go.mod            # Go module definition
├── linker.ld         # Memory layout and linker script
└── Makefile          # Build configuration
```

**Key points:**
- Go code is in `go/mazarin/` package (clean separation from assembly)
- Assembly files are in `asm/` directory
- Build artifacts (`.o`, `.elf`) are created in `src/` root
- The Makefile builds Go package from `go/mazarin/` and assembly from `asm/`

## Docker and QEMU Testing

The `docker/` directory contains scripts and configuration for testing the kernel in QEMU:

```
docker/
├── Dockerfile         # Alpine Linux container with QEMU for AArch64 emulation
├── runqemu            # Run kernel normally in QEMU (for testing)
├── runqemu-fb         # Run QEMU with framebuffer display via VNC
├── runqemu-debug      # Run QEMU with GDB server enabled (for debugging)
├── runqemu-trace      # Run QEMU with instruction tracing (for analysis)
└── builtin/           # Kernel artifacts (kernel.elf copied here via `make push`)
```

**Environment Setup (Required):**
Before using any QEMU scripts, source the environment script:
```bash
source /Users/iansmith/mazzy/enable-mazzy
```

This makes the scripts available in PATH and sets up cross-compiler tools.

**QEMU Configuration:**
- Uses `virt` machine type (better UART compatibility than `raspi4b`)
- CPU: Cortex-A72 (same as Raspberry Pi 4)
- Memory: 512MB
- UART: PL011 at `0x09000000` (matches `uart_qemu.go`)
- Serial output: Redirected to stdio via `-serial stdio`

**Scripts:**

- **runqemu-fb**: Run kernel with framebuffer display via VNC
  - Default VNC port: 5900 (configurable via `VNC_PORT` environment variable)
  - Automatically cleans up orphaned containers from previous runs
  - Uses unique container names (`mazarin-<timestamp>-<pid>`) to avoid conflicts
  - Example: `VNC_PORT=5901 runqemu-fb`
  - For automated testing: `timeout 40 runqemu-fb < /dev/null`
  - Kernel output appears at the end (no informational messages)
  
- **runqemu-debug**: GDB debugging script
  - Enables GDB server on port 1234 (configurable via `GDB_PORT`)
  - Pauses execution at startup, waiting for GDB to connect
  - Connect with: `target-gdb kernel.elf` (after sourcing `enable-mazzy`), then `(gdb) target remote localhost:1234`
  
- **runqemu-trace**: Instruction tracing script
  - Shows instruction addresses as they execute
  - Useful for understanding execution flow
  - Filters to show only CPU 0 traces (other CPUs halt)
  - Trace mode configurable via `TRACE_MODE` (default: `exec`)

**Workflow:**
1. Source environment: `source /Users/iansmith/mazzy/enable-mazzy`
2. Build kernel: `cd src && make kernel-qemu.elf` → creates `kernel-qemu.elf`
3. Copy to docker: `cd src && make push-qemu` → copies `kernel-qemu.elf` to `docker/builtin/kernel.elf`
4. Run in QEMU: `runqemu-fb` (or debug/trace variants)

**Automated Testing:**
For automated testing with timeout:
```bash
source /Users/iansmith/mazzy/enable-mazzy
timeout 40 runqemu-fb < /dev/null 2>&1 | tail -30
```

The script automatically:
- Cleans up any existing `mazarin-*` containers (leftover from previous runs)
- Uses unique container names to avoid port conflicts
- Shows kernel output at the end (look for test results like "T2 N" or "T2 P")

**Container Management:**
- Containers are named `mazarin-<timestamp>-<pid>` for uniqueness
- The script automatically kills and removes existing `mazarin-*` containers before running
- If timeout is used, containers may be left running - the cleanup handles this

## VNC and Framebuffer Display

For graphical display output from QEMU, use VNC:

**Quick Start:**
```bash
source enable-mazzy
cd src && make kernel-qemu.elf && make push-qemu
runqemu-virt-vga  # or runqemu-fb (both support VNC now)
# Connect with VNC client to localhost:5900
```

**Important: Apple Screen Sharing Does NOT Work**
- Apple's built-in VNC viewer has known compatibility issues with QEMU VNC
- Protocol/authentication mismatch causes connection failures or blank screens
- Use RealVNC Viewer (`brew install --cask vnc-viewer`) or TigerVNC (`brew install tiger-vnc`)
- See `docs/qemu-vnc-framebuffer-setup.md` for detailed explanation with sources

**Framebuffer Location:**
- QEMU virt machine uses `bochs-display` device (PCI vendor 0x1234, device 0x1111)
- Kernel finds framebuffer via PCI enumeration (scans config space at 0x30000000)
- Framebuffer address read from PCI BAR0 (typically 0x40000000+)
- Resolution: 640x480, 24-bit RGB (3 bytes per pixel)
- Check UART output for: "findBochsDisplay: Found bochs-display device"

**Documentation:**
- Quick reference: `VNC-QUICKSTART.md`
- Full guide: `docs/qemu-vnc-framebuffer-setup.md`

## When Making Changes

1. If changing bitfield structs: run `make generate` first
2. If adding assembly functions: ensure `.global` and proper calling convention
3. If adding Go functions called from assembly: add `//go:nosplit` and `//go:noinline`
4. If accessing linker symbols: use `//go:linkname`
5. Always run `make test` before committing

See `ARCHITECTURE.md` for detailed explanations of these patterns.

