package main

import (
	"mazboot/asm"
	"unsafe"
)

// Pixel represents an RGB pixel
type Pixel struct {
	Red   uint8
	Green uint8
	Blue  uint8
}

// Font bitmap data - 8x8 characters
// Each character is 8 bytes (one byte per row, 8 rows)
// Bit 7 is leftmost pixel, bit 0 is rightmost pixel
//
//go:nosplit
func font(c byte) *[8]uint8 {
	// Static array inside function (workaround for global array issues in bare metal)
	// This is a simple 8x8 font bitmap
	var fontData [128][8]uint8

	// Initialize all characters to zero
	for i := 0; i < 128; i++ {
		for j := 0; j < 8; j++ {
			fontData[i][j] = 0
		}
	}

	// Define some basic characters
	// Space (0x20)
	fontData[0x20] = [8]uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

	// Numbers 0-9
	fontData['0'] = [8]uint8{0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00}
	fontData['1'] = [8]uint8{0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, 0x00}
	fontData['2'] = [8]uint8{0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00}
	fontData['3'] = [8]uint8{0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00}
	fontData['4'] = [8]uint8{0x06, 0x0E, 0x1E, 0x66, 0x7F, 0x06, 0x06, 0x00}
	fontData['5'] = [8]uint8{0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00}
	fontData['6'] = [8]uint8{0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00}
	fontData['7'] = [8]uint8{0x7E, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00}
	fontData['8'] = [8]uint8{0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00}
	fontData['9'] = [8]uint8{0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00}

	// Letters A-Z (uppercase)
	fontData['A'] = [8]uint8{0x18, 0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x00}
	fontData['B'] = [8]uint8{0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00}
	fontData['C'] = [8]uint8{0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00}
	fontData['D'] = [8]uint8{0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00}
	fontData['E'] = [8]uint8{0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00}
	fontData['F'] = [8]uint8{0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00}
	fontData['G'] = [8]uint8{0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00}
	fontData['H'] = [8]uint8{0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00}
	fontData['I'] = [8]uint8{0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}
	fontData['J'] = [8]uint8{0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00}
	fontData['K'] = [8]uint8{0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00}
	fontData['L'] = [8]uint8{0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00}
	fontData['M'] = [8]uint8{0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00}
	fontData['N'] = [8]uint8{0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00}
	fontData['O'] = [8]uint8{0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}
	fontData['P'] = [8]uint8{0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00}
	fontData['Q'] = [8]uint8{0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00}
	fontData['R'] = [8]uint8{0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00}
	fontData['S'] = [8]uint8{0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00}
	fontData['T'] = [8]uint8{0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}
	fontData['U'] = [8]uint8{0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}
	fontData['V'] = [8]uint8{0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}
	fontData['W'] = [8]uint8{0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00}
	fontData['X'] = [8]uint8{0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00}
	fontData['Y'] = [8]uint8{0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00}
	fontData['Z'] = [8]uint8{0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00}

	// Lowercase a-z
	fontData['a'] = [8]uint8{0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00}
	fontData['b'] = [8]uint8{0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00}
	fontData['c'] = [8]uint8{0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00}
	fontData['d'] = [8]uint8{0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00}
	fontData['e'] = [8]uint8{0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00}
	fontData['f'] = [8]uint8{0x1C, 0x36, 0x30, 0x78, 0x30, 0x30, 0x30, 0x00}
	fontData['g'] = [8]uint8{0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C}
	fontData['h'] = [8]uint8{0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00}
	fontData['i'] = [8]uint8{0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00}
	fontData['j'] = [8]uint8{0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3C}
	fontData['k'] = [8]uint8{0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00}
	fontData['l'] = [8]uint8{0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}
	fontData['m'] = [8]uint8{0x00, 0x00, 0x63, 0x77, 0x7F, 0x6B, 0x63, 0x00}
	fontData['n'] = [8]uint8{0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00}
	fontData['o'] = [8]uint8{0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00}
	fontData['p'] = [8]uint8{0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60}
	fontData['q'] = [8]uint8{0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06}
	fontData['r'] = [8]uint8{0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00}
	fontData['s'] = [8]uint8{0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00}
	fontData['t'] = [8]uint8{0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x1C, 0x00}
	fontData['u'] = [8]uint8{0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00}
	fontData['v'] = [8]uint8{0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}
	fontData['w'] = [8]uint8{0x00, 0x00, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00}
	fontData['x'] = [8]uint8{0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00}
	fontData['y'] = [8]uint8{0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C}
	fontData['z'] = [8]uint8{0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00}

	// Special characters
	fontData['!'] = [8]uint8{0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00}
	fontData['"'] = [8]uint8{0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}
	fontData['#'] = [8]uint8{0x66, 0xFF, 0x66, 0x66, 0xFF, 0x66, 0x66, 0x00}
	fontData['$'] = [8]uint8{0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00}
	fontData['%'] = [8]uint8{0x00, 0x63, 0x66, 0x0C, 0x18, 0x33, 0x63, 0x00}
	fontData['&'] = [8]uint8{0x1C, 0x36, 0x1C, 0x3B, 0x6E, 0x66, 0x3F, 0x00}
	fontData['\''] = [8]uint8{0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00}
	fontData['('] = [8]uint8{0x0E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00}
	fontData[')'] = [8]uint8{0x70, 0x18, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00}
	fontData['*'] = [8]uint8{0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}
	fontData['+'] = [8]uint8{0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00}
	fontData[','] = [8]uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x00}
	fontData['-'] = [8]uint8{0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00}
	fontData['.'] = [8]uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00}
	fontData['/'] = [8]uint8{0x00, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00}
	fontData[':'] = [8]uint8{0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00}
	fontData[';'] = [8]uint8{0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x30, 0x00}
	fontData['<'] = [8]uint8{0x0E, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0E, 0x00}
	fontData['='] = [8]uint8{0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00}
	fontData['>'] = [8]uint8{0x70, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x70, 0x00}
	fontData['?'] = [8]uint8{0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00}
	fontData['@'] = [8]uint8{0x3C, 0x66, 0x6E, 0x6E, 0x60, 0x62, 0x3C, 0x00}
	fontData['['] = [8]uint8{0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00}
	fontData['\\'] = [8]uint8{0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x00}
	fontData[']'] = [8]uint8{0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00}
	fontData['^'] = [8]uint8{0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}
	fontData['_'] = [8]uint8{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00}
	fontData['`'] = [8]uint8{0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00}
	fontData['{'] = [8]uint8{0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00}
	fontData['|'] = [8]uint8{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}
	fontData['}'] = [8]uint8{0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00}
	fontData['~'] = [8]uint8{0x00, 0x00, 0x3B, 0x6E, 0x00, 0x00, 0x00, 0x00}

	return &fontData[c]
}

// writePixel writes a pixel to the framebuffer at coordinates (x, y)
//
//go:nosplit
func writePixel(x, y uint32, pix *Pixel) {
	if fbinfo.Buf == nil {
		return
	}
	if x >= fbinfo.Width || y >= fbinfo.Height {
		return
	}

	// Calculate pixel location: y * pitch + x * bytes_per_pixel
	location := uintptr(fbinfo.Buf) + uintptr(y)*uintptr(fbinfo.Pitch) + uintptr(x)*BYTES_PER_PIXEL

	// Write RGB bytes
	pixelPtr := (*[3]uint8)(unsafe.Pointer(location))
	pixelPtr[0] = pix.Red
	pixelPtr[1] = pix.Green
	pixelPtr[2] = pix.Blue
}

// gpuPutc renders a character to the framebuffer
//
//go:nosplit
func gpuPutc(c byte) {
	if fbinfo.Buf == nil {
		return
	}

	white := Pixel{0xFF, 0xFF, 0xFF}
	black := Pixel{0x00, 0x00, 0x00}

	numRows := fbinfo.CharsHeight

	// Handle scrolling: if we're past the last row, scroll up
	if fbinfo.CharsY >= numRows {
		// Copy each row up by one character row
		for i := uint32(0); i < numRows-1; i++ {
			src := uintptr(fbinfo.Buf) + uintptr((i+1)*CHAR_HEIGHT)*uintptr(fbinfo.Pitch)
			dst := uintptr(fbinfo.Buf) + uintptr(i*CHAR_HEIGHT)*uintptr(fbinfo.Pitch)
			// Copy one character row (CHAR_HEIGHT rows of pixels)
			for row := uint32(0); row < CHAR_HEIGHT; row++ {
				srcRow := src + uintptr(row)*uintptr(fbinfo.Pitch)
				dstRow := dst + uintptr(row)*uintptr(fbinfo.Pitch)
				// Copy one row of pixels (width * bytes_per_pixel)
				for col := uint32(0); col < fbinfo.Width*BYTES_PER_PIXEL; col++ {
					*(*uint8)(unsafe.Pointer(dstRow + uintptr(col))) = *(*uint8)(unsafe.Pointer(srcRow + uintptr(col)))
				}
			}
		}
		// Zero out the last row
		lastRowStart := uintptr(fbinfo.Buf) + uintptr((numRows-1)*CHAR_HEIGHT)*uintptr(fbinfo.Pitch)
		asm.Bzero(unsafe.Pointer(lastRowStart), fbinfo.Pitch*CHAR_HEIGHT)
		fbinfo.CharsY--
	}

	// Handle newline
	if c == '\n' {
		fbinfo.CharsX = 0
		fbinfo.CharsY++
		return
	}

	// Get character bitmap (8x8)
	bmp := font(c)

	// Render character based on CHAR_WIDTH/CHAR_HEIGHT
	// If CHAR_WIDTH/CHAR_HEIGHT is 16, render as 2x2 blocks (16x16 output)
	// If CHAR_WIDTH/CHAR_HEIGHT is 8, render as 1x1 (8x8 output)
	const bitmapWidth = 8  // Original bitmap width
	const bitmapHeight = 8 // Original bitmap height

	if CHAR_WIDTH == 16 && CHAR_HEIGHT == 16 {
		// Render as 16x16 (each bitmap pixel becomes a 2x2 block)
		for w := uint32(0); w < bitmapWidth; w++ {
			for h := uint32(0); h < bitmapHeight; h++ {
				mask := uint8(1 << (7 - w)) // Bit 7 is leftmost
				var pix *Pixel
				if (bmp[h] & mask) != 0 {
					pix = &white
				} else {
					pix = &black
				}

				// Render this bitmap pixel as a 2x2 block
				baseX := fbinfo.CharsX*CHAR_WIDTH + w*2
				baseY := fbinfo.CharsY*CHAR_HEIGHT + h*2

				writePixel(baseX, baseY, pix)
				writePixel(baseX+1, baseY, pix)
				writePixel(baseX, baseY+1, pix)
				writePixel(baseX+1, baseY+1, pix)
			}
		}
	} else {
		// Render as 8x8 (1:1 mapping)
		for w := uint32(0); w < bitmapWidth; w++ {
			for h := uint32(0); h < bitmapHeight; h++ {
				mask := uint8(1 << (7 - w)) // Bit 7 is leftmost
				var pix *Pixel
				if (bmp[h] & mask) != 0 {
					pix = &white
				} else {
					pix = &black
				}

				// Render single pixel
				x := fbinfo.CharsX*CHAR_WIDTH + w
				y := fbinfo.CharsY*CHAR_HEIGHT + h
				writePixel(x, y, pix)
			}
		}
	}

	// Advance cursor
	fbinfo.CharsX++
	if fbinfo.CharsX >= fbinfo.CharsWidth {
		fbinfo.CharsX = 0
		fbinfo.CharsY++
	}
}

// gpuPuts renders a string to the framebuffer
//
//go:nosplit
func gpuPuts(str string) {
	for i := 0; i < len(str); i++ {
		gpuPutc(str[i])
	}
}

// gpuInit initializes the GPU/framebuffer
// Returns 0 on success, non-zero on error
// Note: This function calls framebufferInit which uses significant stack space
func gpuInit() int32 {
	// Initialize framebuffer
	if framebufferInit() != 0 {
		return -1
	}

	// Clear screen (black)
	if fbinfo.Buf != nil && fbinfo.BufSize > 0 {
		asm.Bzero(fbinfo.Buf, fbinfo.BufSize)
	}

	return 0
}
