//go:build ignore
// +build ignore

// Bitfield code generator
// Generates Pack/Unpack functions for structs with bitfield tags
//
// Usage:
//   go run gen.go -package <package_name> -struct <StructName> -source <source_file> -output <output_file>
//
// Example:
//   go run gen.go -package main -struct PageFlags -source ../go/mazboot/page.go -output /tmp/generated.go

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"strings"
)

func main() {
	var packageName = flag.String("package", "", "Package name for generated code (required)")
	var structName = flag.String("struct", "", "Struct name to generate code for (required)")
	var sourceFile = flag.String("source", "", "Source file containing the struct definition (required)")
	var outputFile = flag.String("output", "", "Output file (stdout if not specified)")
	flag.Parse()

	if *packageName == "" || *structName == "" || *sourceFile == "" {
		fmt.Fprintf(os.Stderr, "Error: -package, -struct, and -source flags are required\n")
		fmt.Fprintf(os.Stderr, "Usage: %s -package <package> -struct <StructName> -source <file.go> [-output <file>]\n", os.Args[0])
		os.Exit(1)
	}

	// Parse the source file to find the struct
	structType, err := findStructInFile(*sourceFile, *structName)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error finding struct %s in %s: %v\n", *structName, *sourceFile, err)
		os.Exit(1)
	}

	// Generate code
	generated := generateCode(*packageName, *structName, structType)

	// Write output
	if *outputFile != "" {
		if err := os.WriteFile(*outputFile, []byte(generated), 0644); err != nil {
			fmt.Fprintf(os.Stderr, "Error writing output: %v\n", err)
			os.Exit(1)
		}
	} else {
		os.Stdout.WriteString(generated)
	}
}

// findStructInFile parses a Go file and finds the struct definition
func findStructInFile(filename, structName string) (*ast.StructType, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file: %w", err)
	}

	// Find the struct type
	var structType *ast.StructType
	ast.Inspect(node, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok {
			if ts.Name.Name == structName {
				if st, ok := ts.Type.(*ast.StructType); ok {
					structType = st
					return false // Found it, stop searching
				}
			}
		}
		return true
	})

	if structType == nil {
		return nil, fmt.Errorf("struct %s not found in file", structName)
	}

	return structType, nil
}

// generateCode generates Pack/Unpack functions for a struct
func generateCode(packageName, structName string, structType *ast.StructType) string {
	var buf strings.Builder

	// Write header with package declaration
	buf.WriteString("// Code generated by gen.go; DO NOT EDIT.\n\n")
	buf.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Parse struct fields and generate unpack function
	buf.WriteString(fmt.Sprintf("// Unpack%s unpacks a uint32 into a %s struct.\n", structName, structName))
	buf.WriteString(fmt.Sprintf("func Unpack%s(packed uint32) %s {\n", structName, structName))
	buf.WriteString(fmt.Sprintf("\tvar flags %s\n", structName))

	var bitOffset uint
	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue // Skip embedded fields for now
		}

		// Get bitfield tag
		var bits uint
		if field.Tag != nil {
			tag := field.Tag.Value
			// Parse tag like `bitfield:",1"` or `bitfield:"method,1"`
			tag = strings.Trim(tag, "`")
			if strings.HasPrefix(tag, "bitfield:") {
				tag = strings.TrimPrefix(tag, "bitfield:")
				tag = strings.Trim(tag, "\"")
				// Parse ",1" or "method,1"
				if strings.HasPrefix(tag, ",") {
					fmt.Sscanf(tag, ",%d", &bits)
				} else {
					var methodName string
					fmt.Sscanf(tag, "%s,%d", &methodName, &bits)
				}
			}
		}

		if bits == 0 {
			continue
		}

		fieldName := field.Names[0].Name
		mask := uint32((1 << bits) - 1)

		// Determine field type
		var typeStr string
		switch field.Type.(type) {
		case *ast.Ident:
			typeStr = field.Type.(*ast.Ident).Name
		default:
			typeStr = "uint32" // Default
		}

		// Generate unpack code based on type
		if typeStr == "bool" {
			buf.WriteString(fmt.Sprintf("\tflags.%s = (packed>>%d)&0x%x != 0\n", fieldName, bitOffset, mask))
		} else if strings.HasPrefix(typeStr, "uint") || strings.HasPrefix(typeStr, "int") {
			buf.WriteString(fmt.Sprintf("\tflags.%s = uint32((packed>>%d)&0x%x)\n", fieldName, bitOffset, mask))
		}

		bitOffset += bits
	}

	buf.WriteString("\treturn flags\n")
	buf.WriteString("}\n\n")

	// Generate Pack function (inline, no external dependencies)
	buf.WriteString(fmt.Sprintf("// Pack%s packs a %s struct into a uint32.\n", structName, structName))
	buf.WriteString("// This function explicitly ensures the result is 32 bits, even on 64-bit systems.\n")
	buf.WriteString(fmt.Sprintf("func Pack%s(flags %s) uint32 {\n", structName, structName))
	buf.WriteString("\tvar packed uint32\n")

	// Generate pack code for each field
	bitOffset = 0
	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue // Skip embedded fields
		}

		// Get bitfield tag
		var bits uint
		if field.Tag != nil {
			tag := field.Tag.Value
			tag = strings.Trim(tag, "`")
			if strings.HasPrefix(tag, "bitfield:") {
				tag = strings.TrimPrefix(tag, "bitfield:")
				tag = strings.Trim(tag, "\"")
				if strings.HasPrefix(tag, ",") {
					fmt.Sscanf(tag, ",%d", &bits)
				} else {
					var methodName string
					fmt.Sscanf(tag, "%s,%d", &methodName, &bits)
				}
			}
		}

		if bits == 0 {
			continue
		}

		fieldName := field.Names[0].Name
		mask := uint32((1 << bits) - 1)

		// Determine field type
		var typeStr string
		switch field.Type.(type) {
		case *ast.Ident:
			typeStr = field.Type.(*ast.Ident).Name
		default:
			typeStr = "uint32" // Default
		}

		// Generate pack code based on type
		if typeStr == "bool" {
			buf.WriteString(fmt.Sprintf("\tif flags.%s {\n", fieldName))
			buf.WriteString(fmt.Sprintf("\t\tpacked |= (1 << %d)\n", bitOffset))
			buf.WriteString("\t}\n")
		} else if strings.HasPrefix(typeStr, "uint") || strings.HasPrefix(typeStr, "int") {
			buf.WriteString(fmt.Sprintf("\tpacked |= (uint32(flags.%s) & 0x%x) << %d\n", fieldName, mask, bitOffset))
		}

		bitOffset += bits
	}

	buf.WriteString("\treturn packed\n")
	buf.WriteString("}\n")

	return buf.String()
}
