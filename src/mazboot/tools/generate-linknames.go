//go:build ignore
// +build ignore

// Code generator for linknames.go
// Scans assembly files to generate //go:linkname declarations for .global assembly symbols
// Reads existing file, preserves non-generated content, and inserts generated code between markers.
// Formats output with gofmt.
//
// Usage: go run generate-linknames.go [-asm <dir>] [-file <path>]
//   -asm: Assembly source directory (default: asm/aarch64)
//   -file: Target Go file to modify (default: asm/linknames.go)

package main

import (
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

func main() {
	// Parse command line flags
	var targetFile string
	var asmDir string
	flag.StringVar(&asmDir, "asm", "asm/aarch64", "Assembly source directory")
	flag.StringVar(&targetFile, "file", "asm/linknames.go", "Target Go file to modify")
	flag.Parse()

	// Find all .global symbols from assembly
	globalSymbols := findGlobalSymbols(asmDir)

	// Read existing file and extract before/after content
	beforeContent, afterContent, err := readFileMarkers(targetFile, "// {{ LINKNAME START}}", "//{{ LINKNAME END}}")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading file: %v\n", err)
		os.Exit(1)
	}

	// Generate linknames content
	var generated strings.Builder
	generateLinknamesContent(globalSymbols, asmDir, &generated)

	// Combine all content
	combined := beforeContent + generated.String() + afterContent

	// Format with gofmt
	formatted, err := formatWithGofmt(combined)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: gofmt failed, using unformatted output: %v\n", err)
		formatted = combined
	}

	// Write to file
	if err := ioutil.WriteFile(targetFile, []byte(formatted), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing to %s: %v\n", targetFile, err)
		os.Exit(1)
	}

	fmt.Fprintf(os.Stderr, "Generated %s\n", targetFile)
}

// readFileMarkers reads a file and returns content before markers, after markers
// If file doesn't exist, returns empty before content and default structure
func readFileMarkers(filename, startMarker, endMarker string) (string, string, error) {
	content, err := ioutil.ReadFile(filename)
	if err != nil {
		if os.IsNotExist(err) {
			// File doesn't exist, create default structure
			header := `// DO NOT EDIT THIS FILE. It is generated by the build system.
package asm

import "unsafe"

`
			footer := "\n"
			return header, footer, nil
		}
		return "", "", err
	}

	fileStr := string(content)

	// Find marker positions
	startIdx := strings.Index(fileStr, startMarker)
	endIdx := strings.Index(fileStr, endMarker)

	if startIdx == -1 || endIdx == -1 {
		// Markers not found, return whole file as "before"
		return fileStr, "", nil
	}

	// Extract content before, between, and after markers
	before := fileStr[:startIdx+len(startMarker)]
	after := fileStr[endIdx:]

	return before + "\n", "\n" + after, nil
}

// formatWithGofmt formats Go code using gofmt
func formatWithGofmt(code string) (string, error) {
	cmd := exec.Command("gofmt", "-s")
	cmd.Stdin = strings.NewReader(code)
	output, err := cmd.Output()
	if err != nil {
		return "", err
	}
	return string(output), nil
}

// generateLinknamesContent generates //go:linkname declarations for assembly symbols
// Writes to the provided writer
func generateLinknamesContent(globalSymbols []string, asmDir string, w io.Writer) {
	// Symbols to exclude (not meant for Go linking or already declared elsewhere)
	excluded := map[string]bool{
		"_start":                         true,
		"kernel_main":                    true,
		"exception_vectors":              true,
		"exception_vectors_start_addr":   true,
		"exception_vectors_end":          true,
		"imageDataStart":                 true,
		"imageDataEnd":                   true,
		"write_barrier_dummy_buffer":     true,
		"_binary_boot_mazarin_bin_start": true,
		"_binary_boot_mazarin_bin_end":   true,
		"_binary_boot_mazarin_bin_size":  true,
		// Functions already declared in other Go files
		"read_elr_el1":         true,
		"read_esr_el1":         true,
		"read_far_el1":         true,
		"read_id_aa64pfr0_el1": true,
		"read_scr_el3":         true,
	}

	// Filter and collect valid symbols with their signatures
	type symbolInfo struct {
		name       string
		goName     string
		signature  string
		returnType string
	}

	var symbols []symbolInfo

	// Parse assembly files to get function signatures
	signatures := parseFunctionSignatures(asmDir)

	for _, sym := range globalSymbols {
		// Skip excluded symbols
		if excluded[sym] {
			continue
		}

		// Skip runtime.* symbols (Go runtime handles these)
		if strings.HasPrefix(sym, "runtime.") {
			continue
		}

		// Skip _binary_* linker symbols
		if strings.HasPrefix(sym, "_binary_") {
			continue
		}

		// Convert assembly symbol name to Go function name
		goName := convertToGoName(sym)

		// Get signature from parsed data
		sig, hasSig := signatures[sym]
		var params, retType string
		if hasSig {
			params = sig.params
			retType = sig.returnType
		} else {
			params = ""
			retType = ""
		}

		// Special case: MemmoveBytes is an alias for memmove
		if sym == "MemmoveBytes" && retType == "" {
			if memmoveSig, ok := signatures["memmove"]; ok {
				if params == "" {
					params = memmoveSig.params
				}
				if retType == "" {
					retType = memmoveSig.returnType
				}
			}
		}

		// Special cases for return types that aren't detected automatically
		// Apply overrides even if signature exists but has empty return type
		if retType == "" {
			returnTypeOverrides := map[string]string{
				"get_caller_stack_pointer": "uintptr",
				"mmio_read":                "uint32",
				"mmio_read16":              "uint16",
				"get_g0_addr":              "uintptr",
				"get_m0_addr":              "uintptr",
			}
			if override, ok := returnTypeOverrides[sym]; ok {
				retType = override
			}
		}

		// Special cases for parameters that aren't detected automatically
		if params == "" {
			paramOverrides := map[string]string{
				"switchToGoroutine": "g unsafe.Pointer",
			}
			if override, ok := paramOverrides[sym]; ok {
				params = override
			}
		}

		symbols = append(symbols, symbolInfo{
			name:       sym,
			goName:     goName,
			signature:  params,
			returnType: retType,
		})
	}

	// Sort by Go function name for consistent output
	sort.Slice(symbols, func(i, j int) bool {
		return symbols[i].goName < symbols[j].goName
	})

	// Generate output
	for _, sym := range symbols {
		// Generate //go:linkname directive
		fmt.Fprintf(w, "//go:linkname %s %s\n", sym.goName, sym.name)
		fmt.Fprintf(w, "//go:nosplit\n")

		// Generate function signature
		if sym.returnType != "" {
			fmt.Fprintf(w, "func %s(%s) %s\n\n", sym.goName, sym.signature, sym.returnType)
		} else if sym.signature != "" {
			fmt.Fprintf(w, "func %s(%s)\n\n", sym.goName, sym.signature)
		} else {
			fmt.Fprintf(w, "func %s()\n\n", sym.goName)
		}
	}
}

// convertToGoName converts assembly symbol name to Go function name
func convertToGoName(asmName string) string {
	// Special cases - functions that need to be exported (capitalized)
	specialCases := map[string]string{
		"store_pointer_nobarrier":      "StorePointerNoBarrier", // Exported
		"get_caller_stack_pointer":     "GetCallerStackPointer", // Exported
		"verify_stack_pointer_reading": "VerifyStackPointerReading", // Exported
		"switchToGoroutine":            "SwitchToGoroutine", // Exported
		"systemstack":                  "systemstack",       // Links to runtime.systemstack
		"dsb":                          "Dsb",               // Exported
		"isb":                          "Isb",               // Exported
	}

	if goName, ok := specialCases[asmName]; ok {
		return goName
	}

	// If already CamelCase (starts with uppercase), keep as-is
	if len(asmName) > 0 && asmName[0] >= 'A' && asmName[0] <= 'Z' {
		return asmName
	}

	// Convert snake_case to camelCase for short names (likely to be exported)
	// For longer names, keep as-is unless they're in special cases
	parts := strings.Split(asmName, "_")
	if len(parts) == 1 && len(asmName) <= 6 {
		// Short single-word names: capitalize first letter for export
		if len(asmName) > 0 {
			return strings.ToUpper(string(asmName[0])) + asmName[1:]
		}
	}

	// For compound names, convert snake_case to CamelCase for export
	// e.g., mmio_write -> MmioWrite, uart_putc_pl011 -> UartPutcPl011
	if len(parts) > 1 {
		var result strings.Builder
		for i, part := range parts {
			if len(part) > 0 {
				if i == 0 {
					// First part: capitalize first letter
					result.WriteString(strings.ToUpper(string(part[0])))
					if len(part) > 1 {
						result.WriteString(part[1:])
					}
				} else {
					// Subsequent parts: capitalize first letter
					result.WriteString(strings.ToUpper(string(part[0])))
					if len(part) > 1 {
						result.WriteString(part[1:])
					}
				}
			}
		}
		return result.String()
	}

	// For compound names, keep as-is (like mmio_write, uart_putc_pl011)
	return asmName
}

// functionSignature holds parsed function signature info
type functionSignature struct {
	params     string
	returnType string
}

// parseFunctionSignatures parses assembly files to extract function signatures from comments
func parseFunctionSignatures(asmDir string) map[string]functionSignature {
	signatures := make(map[string]functionSignature)

	// Regex to match function signature comments: // function_name(type1 param1, type2 param2)
	// or // function_name(type1 param1) returns type
	// Also matches "Parameters:" format: // Parameters: w0 = type, w1 = type
	sigRe := regexp.MustCompile(`^//\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]*)\)`)
	// Match comments that mention a return type anywhere on the line.
	// Handles both the canonical "Returns ..." form and inline comments such as
	// "// x0 = register address, returns uint32_t in w0".
	returnRe := regexp.MustCompile(`(?i)^//.*\breturns?\b[: ]*\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*(?:\(|in\s+[wx]\d+|$)`)
	paramsRe := regexp.MustCompile(`Parameters:\s*(.+)`)

	filepath.Walk(asmDir, func(path string, info os.FileInfo, err error) error {
		if err != nil || !strings.HasSuffix(path, ".s") {
			return nil
		}

		content, err := ioutil.ReadFile(path)
		if err != nil {
			return nil
		}

		lines := strings.Split(string(content), "\n")
		for i, line := range lines {
			// First, check for "Returns" comment on current line
			// This handles cases where the return type is documented before the function
			var returnType string
			var funcNameFromReturn string

			// Check current line for "Returns" pattern (must be a comment line)
			if strings.HasPrefix(strings.TrimSpace(line), "//") {
				returnMatches := returnRe.FindStringSubmatch(line)
				if len(returnMatches) >= 2 {
					returnType = strings.TrimSpace(returnMatches[1])
					// Look for function name on previous lines (up to 10 lines back)
					// Look for pattern like "// function_name()" or "// function_name - description"
					for j := i - 1; j >= 0 && j >= i-10; j-- {
						prevLine := lines[j]
						trimmed := strings.TrimSpace(prevLine)
						if strings.HasPrefix(trimmed, "//") {
							// Match "// function_name()" (with optional text after)
							// Example: "// get_caller_stack_pointer() - Returns the caller's stack pointer"
							funcMatch := regexp.MustCompile(`^//\s*([a-zA-Z_][a-zA-Z0-9_]+)\s*\(\)`).FindStringSubmatch(trimmed)
							if len(funcMatch) >= 2 {
								funcNameFromReturn = funcMatch[1]
								break
							}
							// Try "// function_name -" or "// function_name:"
							funcMatch = regexp.MustCompile(`^//\s*([a-zA-Z_][a-zA-Z0-9_]+)\s*[-:]`).FindStringSubmatch(trimmed)
							if len(funcMatch) >= 2 {
								funcNameFromReturn = funcMatch[1]
								break
							}
						}
					}
				}
			}

			// Check for function signature comment
			matches := sigRe.FindStringSubmatch(line)
			if len(matches) >= 3 {
				funcName := matches[1]
				paramsStr := matches[2]

				// Check next line for return type if we don't have one yet
				if returnType == "" && i+1 < len(lines) {
					returnMatches := returnRe.FindStringSubmatch(lines[i+1])
					if len(returnMatches) >= 2 {
						returnType = strings.TrimSpace(returnMatches[1])
					}
				}
				// Also check current line for "returns" pattern if we don't have one yet
				if returnType == "" {
					returnMatches := returnRe.FindStringSubmatch(line)
					if len(returnMatches) >= 2 {
						returnType = strings.TrimSpace(returnMatches[1])
					}
				}

				// Convert C types to Go types
				goParams := convertCParamsToGo(paramsStr)
				goReturnType := convertCTypeToGo(returnType)

				signatures[funcName] = functionSignature{
					params:     goParams,
					returnType: goReturnType,
				}
			}

			// If we found a return type but no function signature, store it for later
			if returnType != "" && funcNameFromReturn != "" {
				if _, exists := signatures[funcNameFromReturn]; !exists {
					signatures[funcNameFromReturn] = functionSignature{
						params:     "",
						returnType: convertCTypeToGo(returnType),
					}
				} else {
					// Update existing signature with return type if it doesn't have one
					existing := signatures[funcNameFromReturn]
					if existing.returnType == "" {
						existing.returnType = convertCTypeToGo(returnType)
						signatures[funcNameFromReturn] = existing
					}
				}
			}

			// Also check for "Parameters:" format: // Parameters: w0 = type, w1 = type
			// This is used in some assembly files
			paramMatches := paramsRe.FindStringSubmatch(line)
			if len(paramMatches) >= 2 {
				// Look backwards to find the function name (should be on previous line or same line)
				var funcName string
				if i > 0 {
					// Check previous line for function name
					prevLine := lines[i-1]
					funcNameMatch := regexp.MustCompile(`^//\s*([a-zA-Z_][a-zA-Z0-9_]+)`).FindStringSubmatch(prevLine)
					if len(funcNameMatch) >= 2 {
						funcName = funcNameMatch[1]
					}
				}
				// Also check current line
				if funcName == "" {
					funcNameMatch := regexp.MustCompile(`^//\s*([a-zA-Z_][a-zA-Z0-9_]+)`).FindStringSubmatch(line)
					if len(funcNameMatch) >= 2 {
						funcName = funcNameMatch[1]
					}
				}

				if funcName != "" {
					// Parse "w0 = character to send (byte)" format
					paramsStr := paramMatches[1]
					// Extract type from "(type)" pattern first (more specific)
					// Then fall back to single word after "="
					var paramType string
					parenMatch := regexp.MustCompile(`\(([^)]+)\)`).FindStringSubmatch(paramsStr)
					if len(parenMatch) >= 2 {
						paramType = strings.TrimSpace(parenMatch[1])
					} else {
						// Try to extract single word type after "="
						equalMatch := regexp.MustCompile(`=\s*([a-zA-Z_][a-zA-Z0-9_]*)\s`).FindStringSubmatch(paramsStr)
						if len(equalMatch) >= 2 {
							paramType = strings.TrimSpace(equalMatch[1])
						}
					}
					if paramType != "" {
						// Convert register-based type to Go type
						goType := convertCTypeToGo(paramType)
						if goType == "" {
							// Default to byte for character parameters
							goType = "byte"
						}
						signatures[funcName] = functionSignature{
							params:     fmt.Sprintf("c %s", goType),
							returnType: "",
						}
					}
				}
			}
		}

		return nil
	})

	return signatures
}

// convertCParamsToGo converts C-style parameter list to Go-style
func convertCParamsToGo(cParams string) string {
	if strings.TrimSpace(cParams) == "" {
		return ""
	}

	// Split by comma
	params := strings.Split(cParams, ",")
	var goParams []string

	for _, p := range params {
		p = strings.TrimSpace(p)
		if p == "" {
			continue
		}

		// Handle different pointer patterns:
		// - "void *name" -> pointer to void (unsafe.Pointer)
		// - "*type name" -> pointer to type
		// - "type* name" -> pointer to type (C style)
		// - "type *name" -> pointer to type
		var isPtr bool
		var cType, paramName string

		// Check for "*type name" pattern
		if strings.HasPrefix(p, "*") {
			isPtr = true
			rest := strings.TrimSpace(strings.TrimPrefix(p, "*"))
			parts := strings.Fields(rest)
			if len(parts) >= 1 {
				cType = parts[0]
				if len(parts) >= 2 {
					paramName = parts[1]
				} else {
					paramName = "p"
				}
			}
		} else {
			// Parse: "type name" or "type* name" or "type *name" or "name *type"
			parts := strings.Fields(p)
			if len(parts) == 0 {
				continue
			}

			if len(parts) == 1 {
				// Just type, check for * suffix
				cType = parts[0]
				if strings.HasSuffix(cType, "*") {
					isPtr = true
					cType = strings.TrimSuffix(cType, "*")
				}
				paramName = "p"
			} else if len(parts) == 2 {
				// Could be "type name", "type* name", "type *name", or "name *type", or "name type"
				// Heuristic: if first part looks like a type (ends with _t, is void/int/etc), it's "type name"
				// Otherwise, assume "name type"
				firstLooksLikeType := strings.HasSuffix(parts[0], "_t") ||
					parts[0] == "void" || parts[0] == "int" || parts[0] == "uint32" ||
					parts[0] == "uint64" || parts[0] == "uint16" || parts[0] == "uint8" ||
					parts[0] == "int32" || parts[0] == "size_t" || parts[0] == "unsafe.Pointer"

				if strings.HasSuffix(parts[0], "*") {
					// "type* name"
					isPtr = true
					cType = strings.TrimSuffix(parts[0], "*")
					paramName = parts[1]
				} else if strings.HasPrefix(parts[1], "*") {
					// Could be "type *name" (C style: void *ptr) or "name *type" (less common)
					// Check if first part looks like a type
					if firstLooksLikeType {
						// "type *name" - e.g., "void *ptr"
						cType = parts[0]
						paramName = strings.TrimPrefix(parts[1], "*")
						isPtr = true
					} else {
						// "name *type" - name comes first, then pointer to type
						paramName = parts[0]
						isPtr = true
						cType = strings.TrimPrefix(parts[1], "*")
					}
				} else if firstLooksLikeType {
					// "type name" (C style: type_t name)
					cType = parts[0]
					paramName = parts[1]
				} else {
					// "name type" (Go style: name type) - e.g., "value unsafe.Pointer"
					paramName = parts[0]
					cType = parts[1]
				}
			} else {
				// 3+ parts: could be "type * name" or "name * type"
				// Look for standalone "*"
				starIdx := -1
				for i := 1; i < len(parts)-1; i++ {
					if parts[i] == "*" {
						starIdx = i
						isPtr = true
						break
					}
				}
				if starIdx > 0 {
					// "*" found, determine if it's "type * name" or "name * type"
					// If parts before * look like a type and parts after look like a name, it's "type * name"
					// Otherwise assume "name * type"
					if starIdx == 1 && len(parts) == 3 {
						// Could be either, check if first part looks like a type name
						// For now, assume "name * type" pattern (more common in C)
						paramName = parts[0]
						cType = parts[2]
					} else {
						// "type * name"
						cType = parts[0]
						paramName = parts[starIdx+1]
					}
				} else {
					// No standalone *, take first as type, last as name
					cType = parts[0]
					if strings.HasSuffix(cType, "*") {
						isPtr = true
						cType = strings.TrimSuffix(cType, "*")
					}
					paramName = parts[len(parts)-1]
					if strings.HasPrefix(paramName, "*") {
						isPtr = true
						paramName = strings.TrimPrefix(paramName, "*")
					}
				}
			}
		}

		// Convert C type to Go type
		goType := convertCTypeToGo(cType)
		if isPtr {
			if goType == "" || goType == "void" {
				goType = "unsafe.Pointer"
			} else {
				goType = "*" + goType
			}
		}

		goParams = append(goParams, fmt.Sprintf("%s %s", paramName, goType))
	}

	return strings.Join(goParams, ", ")
}

// convertCTypeToGo converts C type to Go type
func convertCTypeToGo(cType string) string {
	cType = strings.TrimSpace(cType)

	// Map C types to Go types (before removing _t)
	typeMap := map[string]string{
		"uintptr_t":      "uintptr",
		"uint32_t":       "uint32",
		"uint64_t":       "uint64",
		"uint16_t":       "uint16",
		"uint8_t":        "uint8",
		"int32_t":        "int32",
		"int":            "int",
		"void":           "",
		"byte":           "byte",
		"size_t":         "uint32", // size_t typically maps to uint32 in our context
		"unsafe.Pointer": "unsafe.Pointer",
	}

	// Check exact match first
	if goType, ok := typeMap[cType]; ok {
		return goType
	}

	// Remove trailing _t and check again
	cTypeNoSuffix := strings.TrimSuffix(cType, "_t")
	if goType, ok := typeMap[cTypeNoSuffix]; ok {
		return goType
	}

	// If it's already a Go-like type, return as-is
	if cType == "uintptr" || cType == "uint32" || cType == "uint64" ||
		cType == "uint16" || cType == "uint8" || cType == "int32" ||
		cType == "int" || cType == "byte" || cType == "unsafe.Pointer" {
		return cType
	}

	// Default: return as-is (might be a struct or other type)
	return cType
}

// findGlobalSymbols scans assembly files for .global symbols
func findGlobalSymbols(asmDir string) []string {
	var symbols []string
	globalRe := regexp.MustCompile(`^\.global\s+([a-zA-Z_][a-zA-Z0-9_.]*)`)

	filepath.Walk(asmDir, func(path string, info os.FileInfo, err error) error {
		if err != nil || !strings.HasSuffix(path, ".s") {
			return nil
		}

		content, err := ioutil.ReadFile(path)
		if err != nil {
			return nil
		}

		lines := strings.Split(string(content), "\n")
		for _, line := range lines {
			matches := globalRe.FindStringSubmatch(line)
			if len(matches) > 1 {
				symbols = append(symbols, matches[1])
			}
		}

		return nil
	})

	return symbols
}


