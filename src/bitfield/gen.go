//go:build ignore
// +build ignore

// This file generates unpacking code for PageFlags.
// Run with: go run gen.go > page_flags_gen.go

package main

import (
	"fmt"
	"os"
	"reflect"
	"strings"
)

func main() {
	// Define the struct we want to generate code for
	type PageFlags struct {
		Allocated  bool   `bitfield:",1"`
		KernelPage bool   `bitfield:",1"`
		Reserved   uint32 `bitfield:",30"`
	}

	t := reflect.TypeOf((*PageFlags)(nil)).Elem()

	var buf strings.Builder

	// Write package declaration
	buf.WriteString("// Code generated by gen.go; DO NOT EDIT.\n\n")
	buf.WriteString("package bitfield\n\n")
	buf.WriteString("import (\n")
	buf.WriteString("\t\"fmt\"\n")
	buf.WriteString(")\n\n")

	// Generate Unpack method
	buf.WriteString("// UnpackPageFlags unpacks a uint32 into a PageFlags struct.\n")
	buf.WriteString("func UnpackPageFlags(packed uint32) PageFlags {\n")
	buf.WriteString("\tvar flags PageFlags\n")

	var bitOffset uint
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		tag := field.Tag.Get("bitfield")
		if tag == "" {
			continue
		}

		var bits uint
		_, err := fmt.Sscanf(tag, ",%d", &bits)
		if err != nil {
			var methodName string
			_, err := fmt.Sscanf(tag, "%s,%d", &methodName, &bits)
			if err != nil {
				continue
			}
		}

		if bits == 0 {
			continue
		}

		fieldName := field.Name
		mask := uint32((1 << bits) - 1)

		switch field.Type.Kind() {
		case reflect.Bool:
			buf.WriteString(fmt.Sprintf("\tflags.%s = (packed>>%d)&0x%x != 0\n", fieldName, bitOffset, mask))
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			buf.WriteString(fmt.Sprintf("\tflags.%s = uint32((packed>>%d)&0x%x)\n", fieldName, bitOffset, mask))
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			buf.WriteString(fmt.Sprintf("\tflags.%s = int32((packed>>%d)&0x%x)\n", fieldName, bitOffset, mask))
		}

		bitOffset += bits
	}

	buf.WriteString("\treturn flags\n")
	buf.WriteString("}\n\n")

	// Generate helper methods
	buf.WriteString("// PackPageFlags packs a PageFlags struct into a uint32.\n")
	buf.WriteString("// This function explicitly ensures the result is 32 bits, even on 64-bit systems.\n")
	buf.WriteString("func PackPageFlags(flags PageFlags) (uint32, error) {\n")
	buf.WriteString("\tpacked, err := Pack(&flags, &Config{NumBits: 32})\n")
	buf.WriteString("\tif err != nil {\n")
	buf.WriteString("\t\treturn 0, fmt.Errorf(\"PackPageFlags: %w\", err)\n")
	buf.WriteString("\t}\n")
	buf.WriteString("\t// Explicitly mask to 32 bits to ensure we never exceed uint32 range\n")
	buf.WriteString("\t// This is important on 64-bit systems where uint64 is the default\n")
	buf.WriteString("\tresult := uint32(packed & 0xFFFFFFFF)\n")
	buf.WriteString("\treturn result, nil\n")
	buf.WriteString("}\n")

	os.Stdout.WriteString(buf.String())
}
