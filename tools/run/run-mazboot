#!/bin/bash

# Script to run QEMU locally (not in container) with Cocoa display (native macOS)
# This uses the same command line as runqemu-virt-vga but runs QEMU directly on the host
#
# Usage:
#   run-mazboot                       # Normal mode with Cocoa display (output streams mixed)
#   SEPARATE_OUTPUT=1 run-mazboot     # Separate kernel and QEMU debug output to files
#   NOGRAPHIC=1 run-mazboot           # Terminal-only mode (no GUI window)
#   SCREENSHOT=1 run-mazboot          # Take screenshot via VNC after boot
#   SCREENSHOT_DELAY=5 SCREENSHOT=1 run-mazboot  # Wait 5 seconds before screenshot
#
# Screenshot Mode:
#   - Runs QEMU with VNC display on localhost:5900
#   - Waits for boot (default 3 seconds, configurable via SCREENSHOT_DELAY)
#   - Takes screenshot using vncsnapshot and saves to PROJECT_ROOT/screenshots/
#   - Requires: brew install vncsnapshot
#
# Output Streams:
#   - Kernel UART (PL011) → stdout (via -serial stdio)
#   - QEMU errors/debug → stderr
#
# When SEPARATE_OUTPUT=1:
#   - Kernel output → kernel-uart.log
#   - QEMU debug → qemu-debug.log
#   - Both also shown in terminal

# Get script directory and project root
# Handle symlinks by resolving to the actual script location
# Use a while loop to follow symlinks (works on macOS and Linux)
SCRIPT_PATH="$0"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    LINK_TARGET="$(readlink "$SCRIPT_PATH")"
    if [ "${LINK_TARGET#/}" = "$LINK_TARGET" ]; then
        # Relative symlink
        SCRIPT_PATH="$SCRIPT_DIR/$LINK_TARGET"
    else
        # Absolute symlink
        SCRIPT_PATH="$LINK_TARGET"
    fi
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

# Use flash directory (relative to project root)
FLASH_DIR="$PROJECT_ROOT/flash"
KERNEL_PATH="$FLASH_DIR/mazboot.elf"
BUILD_BINARY="$PROJECT_ROOT/build/mazboot/mazboot.elf"

# Verify flash directory exists
if [ ! -d "$FLASH_DIR" ]; then
    echo "Error: flash directory does not exist at $FLASH_DIR" >&2
    exit 1
fi

# Verify mazboot.elf exists in flash directory
if [ ! -f "$KERNEL_PATH" ]; then
    echo "Error: mazboot.elf not found at $KERNEL_PATH" >&2
    echo "Please copy mazboot to flash directory first" >&2
    exit 1
fi

# Verify build binary exists for date comparison
if [ ! -f "$BUILD_BINARY" ]; then
    echo "Error: build binary not found at $BUILD_BINARY" >&2
    echo "Please build mazboot first: cd src/mazboot && make mazboot" >&2
    exit 1
fi

# Compare modification dates: flash/mazboot.elf must be >= build/mazboot
FLASH_DATE=$(stat -f %m "$KERNEL_PATH" 2>/dev/null || stat -c %Y "$KERNEL_PATH" 2>/dev/null)
BUILD_DATE=$(stat -f %m "$BUILD_BINARY" 2>/dev/null || stat -c %Y "$BUILD_BINARY" 2>/dev/null)

if [ -z "$FLASH_DATE" ] || [ -z "$BUILD_DATE" ]; then
    echo "Error: Could not determine file modification dates" >&2
    exit 1
fi

if [ "$FLASH_DATE" -lt "$BUILD_DATE" ]; then
    echo "Error: flash/mazboot.elf is older than build/mazboot/mazboot.elf" >&2
    echo "  flash/mazboot.elf: $(date -r "$FLASH_DATE" 2>/dev/null || date -d "@$FLASH_DATE" 2>/dev/null || echo "timestamp $FLASH_DATE")" >&2
    echo "  build/mazboot/mazboot.elf: $(date -r "$BUILD_DATE" 2>/dev/null || date -d "@$BUILD_DATE" 2>/dev/null || echo "timestamp $BUILD_DATE")" >&2
    echo "Please rebuild and copy the latest build to flash directory:" >&2
    echo "  cd src/mazboot && make mazboot" >&2
    exit 1
fi

# Check for homebrew QEMU first, then custom debug QEMU, fall back to system QEMU
HOMEBREW_QEMU="$HOME/mazzy/bin/qemu-system-aarch64"
CUSTOM_QEMU="/tmp/qemu-source/build/qemu-system-aarch64"

if [ -f "$HOMEBREW_QEMU" ]; then
    QEMU_BIN="$HOMEBREW_QEMU"
    echo "Using homebrew QEMU: $QEMU_BIN"
elif [ -f "$CUSTOM_QEMU" ]; then
    QEMU_BIN="$CUSTOM_QEMU"
    echo "Using custom debug QEMU: $QEMU_BIN"
else
    QEMU_BIN="qemu-system-aarch64"
    if ! command -v qemu-system-aarch64 &> /dev/null; then
        echo "Error: qemu-system-aarch64 not found in PATH" >&2
        echo "Please install QEMU or add it to your PATH" >&2
        exit 1
    fi
    echo "Using system QEMU: $(which qemu-system-aarch64)"
fi

# Check for output separation mode
SEPARATE_OUTPUT="${SEPARATE_OUTPUT:-0}"
NOGRAPHIC="${NOGRAPHIC:-0}"
SCREENSHOT="${SCREENSHOT:-0}"
SCREENSHOT_DELAY="${SCREENSHOT_DELAY:-3}"

# Screenshot directory
SCREENSHOT_DIR="$PROJECT_ROOT/screenshots"

if [ "$SCREENSHOT" = "1" ]; then
    # Create screenshot directory
    mkdir -p "$SCREENSHOT_DIR"

    # Use QEMU monitor for screenshots (no external tools needed)
    MONITOR_SOCKET="/tmp/qemu-monitor-$$.sock"

    echo "Starting QEMU in screenshot mode (using QEMU monitor)"
    DISPLAY_MODE="-display cocoa"
elif [ "$NOGRAPHIC" = "1" ]; then
    echo "Starting QEMU in nographic mode (terminal only, no GUI)"
    DISPLAY_MODE="-nographic"
else
    echo "Starting QEMU locally with 'virt' machine type and Cocoa display"
    DISPLAY_MODE="-display cocoa"
fi

echo ""
echo "NOTE: Using 'virt' machine type instead of 'raspi4b' for better"
echo "      display device support. This is a generic AArch64 virtual machine."
echo ""
echo "      This script uses bochs-display device for framebuffer output."
echo ""
echo "      SD card support: SDHCI PCI device with SD card image at /tmp/sdcard.img"
echo "      The SD card image will be created automatically if it doesn't exist."
echo ""
echo "      The kernel is built for Raspberry Pi, so some hardware-specific"
echo "      features (like UART) may not work correctly with 'virt' machine."
echo ""

if [ "$NOGRAPHIC" != "1" ]; then
    echo "Cocoa display window will open automatically"
fi

echo "UART output will appear in this terminal"
echo ""
echo ""

if [ "$SEPARATE_OUTPUT" = "1" ]; then
    echo "Output separation enabled:"
    echo "  - Kernel UART → kernel-uart.log"
    echo "  - QEMU debug → qemu-debug.log"
    echo ""
fi

echo "Press Ctrl+C to stop QEMU"
echo ""

# Create log directory if it doesn't exist
LOG_DIR="/tmp/qemu-logs"
mkdir -p "$LOG_DIR"

# Get QEMU version for debugging
echo "QEMU version:"
"$QEMU_BIN" --version
echo ""
mkdir -p "$LOG_DIR"

# Run QEMU locally with Cocoa display or nographic mode
# 
# Output Stream Routing (from QEMU-OUTPUT-AND-DEBUGGING.md):
#   - Kernel UART (PL011) → stdout (via -serial stdio)
#   - QEMU errors → stderr
#   - QEMU debug fprintf → stderr
#
# Serial Configuration:
#   -serial stdio: Direct connection (UART → stdout)
#     * Kernel output appears directly in terminal
#     * Simple and reliable for bare-metal kernels
#     * Note: mon:stdio allows monitor access but may not route PL011 correctly
#
# Option explanations:
#   -M virt: Use QEMU's generic AArch64 virtual machine (better device support than raspi4b)
#   -cpu cortex-a72: Use Cortex-A72 CPU (matches Raspberry Pi 4)
#   -m 1G: Allocate 1GB RAM (for kernel development)
#   -kernel: Load bare-metal kernel ELF file (standard QEMU way, simpler than -device loader)
#   -device bochs-display: Add bochs-display device (PCI framebuffer, configured via VBE registers)
#   -display cocoa: Use Cocoa display backend (native macOS window) OR -nographic for terminal-only
#   -serial stdio: Redirect UART output directly to stdout
#   -no-reboot: Exit on shutdown instead of rebooting
#   -D: Log file path for QEMU debug output
# SD card image path
SDCARD_IMG="/tmp/sdcard.img"

# Create SD card image if it doesn't exist
if [ ! -f "$SDCARD_IMG" ]; then
    echo "Creating SD card image at $SDCARD_IMG (64MB)..."
    dd if=/dev/zero of="$SDCARD_IMG" bs=1M count=64 2>/dev/null
    if [ $? -ne 0 ]; then
        echo "Warning: Failed to create SD card image, continuing anyway" >&2
    else
        echo "SD card image created successfully"
    fi
fi

# Build QEMU command (base arguments)
QEMU_CMD=(
    "$QEMU_BIN"
    -M virt,virtualization=off
    -cpu cortex-a72
    -m 8G
    -kernel "$KERNEL_PATH"
    -nodefaults     # Disable default devices to avoid serial conflicts
    -device bochs-display
    -device sdhci-pci
    -drive if=none,file="$SDCARD_IMG",format=raw,id=sdcard
    -device sd-card,drive=sdcard
    -device virtio-rng-pci  # RNG device for random number generation
    $DISPLAY_MODE
    -serial stdio   # Direct UART output to terminal
    -semihosting
    -no-reboot
)

# Add monitor socket for screenshot mode
if [ "$SCREENSHOT" = "1" ]; then
    QEMU_CMD+=(-monitor "unix:$MONITOR_SOCKET,server,nowait")
fi

# Optional: enable QEMU tracing/debugging
# Usage:
#   QEMU_TRACE=1 run-mazboot
#   QEMU_TRACE_FLAGS=guest_errors,unimp,mmu,pcall run-mazboot
#
# When enabled:
#   - Adds "-d <flags>" to QEMU (default: guest_errors,unimp,mmu)
#   - Adds "-D <trace-log>" to QEMU (separate trace log file)
if [ "${QEMU_TRACE:-0}" != "0" ]; then
    # Default trace flags if none provided
    TRACE_FLAGS="${QEMU_TRACE_FLAGS:-guest_errors,unimp,mmu}"

    # Ensure log directory exists (it should already from above, but be safe)
    mkdir -p "$LOG_DIR"

    # Trace log file (separate from the stderr debug log)
    QEMU_TRACE_LOG="$LOG_DIR/qemu-trace-$$.log"

    echo "Enabling QEMU tracing:"
    echo "  -d $TRACE_FLAGS"
    echo "  -D $QEMU_TRACE_LOG"
    echo ""

    QEMU_CMD+=(
        -d "$TRACE_FLAGS"
        -D "$QEMU_TRACE_LOG"
    )
fi

# Display the full command line
echo "QEMU command:"
echo "${QEMU_CMD[@]}"
echo ""

# Set up output redirection if requested
if [ "$SCREENSHOT" = "1" ]; then
    # Screenshot mode: run QEMU in background, take screenshot via monitor, then kill it
    TIMESTAMP=$(date +%Y%m%d-%H%M%S)
    SCREENSHOT_PPM="/tmp/mazboot-screenshot-$$.ppm"
    SCREENSHOT_FILE="$SCREENSHOT_DIR/mazboot-$TIMESTAMP.png"

    echo "Screenshot mode enabled:"
    echo "  Monitor socket: $MONITOR_SOCKET"
    echo "  Delay: ${SCREENSHOT_DELAY}s"
    echo "  Output: $SCREENSHOT_FILE"
    echo ""

    # Clean up any existing socket
    rm -f "$MONITOR_SOCKET"

    # Start QEMU in background (redirect stdout/stderr to avoid mixing with our output)
    "${QEMU_CMD[@]}" >/dev/null 2>&1 &
    QEMU_PID=$!

    # Wait for QEMU to start and socket to be available
    echo "Waiting for QEMU to start..."
    for i in {1..10}; do
        if [ -S "$MONITOR_SOCKET" ]; then
            break
        fi
        sleep 0.5
    done

    # Check if socket exists
    if [ ! -S "$MONITOR_SOCKET" ]; then
        echo "Error: QEMU monitor socket not created" >&2
        kill $QEMU_PID 2>/dev/null
        exit 1
    fi

    # Check if QEMU is still running
    if ! kill -0 $QEMU_PID 2>/dev/null; then
        echo "Error: QEMU failed to start" >&2
        exit 1
    fi

    # Wait for boot to complete
    echo "Waiting ${SCREENSHOT_DELAY}s for boot to complete..."
    sleep "$SCREENSHOT_DELAY"

    # Take screenshot via QEMU monitor (screendump command)
    echo "Taking screenshot..."
    # Send screendump command to monitor socket using netcat (nc)
    echo "screendump $SCREENSHOT_PPM" | nc -U "$MONITOR_SOCKET" >/dev/null 2>&1
    sleep 0.5  # Give QEMU time to write the file

    # Check if PPM was created
    if [ -f "$SCREENSHOT_PPM" ]; then
        # Convert PPM to PNG using sips (macOS built-in)
        if sips -s format png "$SCREENSHOT_PPM" --out "$SCREENSHOT_FILE" >/dev/null 2>&1; then
            echo "Screenshot saved: $SCREENSHOT_FILE"
            rm -f "$SCREENSHOT_PPM"
        else
            echo "Warning: Failed to convert to PNG, keeping PPM"
            mv "$SCREENSHOT_PPM" "${SCREENSHOT_FILE%.png}.ppm"
            SCREENSHOT_FILE="${SCREENSHOT_FILE%.png}.ppm"
            echo "Screenshot saved: $SCREENSHOT_FILE"
        fi
    else
        echo "Error: Failed to take screenshot" >&2
        echo "QEMU may not have finished booting. Try increasing SCREENSHOT_DELAY." >&2
    fi

    # Kill QEMU
    echo "Stopping QEMU..."
    echo "quit" | nc -U "$MONITOR_SOCKET" >/dev/null 2>&1
    sleep 0.5
    kill $QEMU_PID 2>/dev/null
    wait $QEMU_PID 2>/dev/null

    # Clean up socket
    rm -f "$MONITOR_SOCKET"

    echo ""
    echo "Done. Screenshot: $SCREENSHOT_FILE"

elif [ "$SEPARATE_OUTPUT" = "1" ]; then
    KERNEL_LOG="$LOG_DIR/kernel-uart-$$.log"
    QEMU_DEBUG_LOG="$LOG_DIR/qemu-debug-$$.log"

    echo "Separating output streams:"
    echo "  Kernel UART → $KERNEL_LOG"
    echo "  QEMU debug → $QEMU_DEBUG_LOG"
    echo ""

    # Execute QEMU with separated output
    # Kernel UART (stdout) → kernel log (also shown in terminal via tee)
    # QEMU debug (stderr) → QEMU debug log (also shown in terminal via tee)
    # Note: This uses process substitution which works in bash
    "${QEMU_CMD[@]}" < /dev/null \
        2> >(tee "$QEMU_DEBUG_LOG" >&2) \
        | tee "$KERNEL_LOG"

    echo ""
    echo "Output logs saved:"
    echo "  Kernel UART: $KERNEL_LOG"
    echo "  QEMU debug: $QEMU_DEBUG_LOG"
else
    # Execute QEMU normally (output mixed in terminal)
    # All output (kernel UART + QEMU debug) appears together
    "${QEMU_CMD[@]}"
fi



