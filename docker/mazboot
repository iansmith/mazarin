#!/bin/bash

# Script to run QEMU locally (not in container) with Cocoa display (native macOS)
# This uses the same command line as runqemu-virt-vga but runs QEMU directly on the host
#
# Usage:
#   docker/mazboot                    # Normal mode with Cocoa display (output streams mixed)
#   SEPARATE_OUTPUT=1 docker/mazboot  # Separate kernel and QEMU debug output to files
#   NOGRAPHIC=1 docker/mazboot        # Terminal-only mode (no GUI window)
#
# Output Streams:
#   - Kernel UART (PL011) → stdout (via -serial stdio)
#   - QEMU errors/debug → stderr
#
# When SEPARATE_OUTPUT=1:
#   - Kernel output → kernel-uart.log
#   - QEMU debug → qemu-debug.log
#   - Both also shown in terminal

# Use absolute path to builtin directory
BUILTIN_DIR="/Users/iansmith/mazzy/docker/builtin"
KERNEL_PATH="$BUILTIN_DIR/kernel.elf"

# Verify builtin directory exists
if [ ! -d "$BUILTIN_DIR" ]; then
    echo "Error: builtin directory does not exist at $BUILTIN_DIR" >&2
    exit 1
fi

# Verify kernel.elf exists
if [ ! -f "$KERNEL_PATH" ]; then
    echo "Error: kernel.elf not found at $KERNEL_PATH" >&2
    echo "Please build the QEMU kernel first: cd src && make push-qemu" >&2
    exit 1
fi

# Check for homebrew QEMU first, then custom debug QEMU, fall back to system QEMU
HOMEBREW_QEMU="$HOME/mazzy/bin/qemu-system-aarch64"
CUSTOM_QEMU="/tmp/qemu-source/build/qemu-system-aarch64"

if [ -f "$HOMEBREW_QEMU" ]; then
    QEMU_BIN="$HOMEBREW_QEMU"
    echo "Using homebrew QEMU: $QEMU_BIN"
elif [ -f "$CUSTOM_QEMU" ]; then
    QEMU_BIN="$CUSTOM_QEMU"
    echo "Using custom debug QEMU: $QEMU_BIN"
else
    QEMU_BIN="qemu-system-aarch64"
    if ! command -v qemu-system-aarch64 &> /dev/null; then
        echo "Error: qemu-system-aarch64 not found in PATH" >&2
        echo "Please install QEMU or add it to your PATH" >&2
        exit 1
    fi
    echo "Using system QEMU: $(which qemu-system-aarch64)"
fi

# Check for output separation mode
SEPARATE_OUTPUT="${SEPARATE_OUTPUT:-0}"
NOGRAPHIC="${NOGRAPHIC:-0}"

if [ "$NOGRAPHIC" = "1" ]; then
    echo "Starting QEMU in nographic mode (terminal only, no GUI)"
    DISPLAY_MODE="-nographic"
else
    echo "Starting QEMU locally with 'virt' machine type and Cocoa display"
    DISPLAY_MODE="-display cocoa"
fi

echo ""
echo "NOTE: Using 'virt' machine type instead of 'raspi4b' for better"
echo "      display device support. This is a generic AArch64 virtual machine."
echo ""
echo "      This script uses ramfb device, which works better with AArch64."
echo "      Note: bochs-display has known PCI memory bar caching issues on ARM."
echo ""
echo "      The kernel is built for Raspberry Pi, so some hardware-specific"
echo "      features (like UART) may not work correctly with 'virt' machine."
echo ""

if [ "$NOGRAPHIC" != "1" ]; then
    echo "Cocoa display window will open automatically"
fi

echo "UART output will appear in this terminal"
echo ""
echo ""

if [ "$SEPARATE_OUTPUT" = "1" ]; then
    echo "Output separation enabled:"
    echo "  - Kernel UART → kernel-uart.log"
    echo "  - QEMU debug → qemu-debug.log"
    echo ""
fi

echo "Press Ctrl+C to stop QEMU"
echo ""

# Create log directory if it doesn't exist
LOG_DIR="/tmp/qemu-logs"
mkdir -p "$LOG_DIR"

# Get QEMU version for debugging
echo "QEMU version:"
"$QEMU_BIN" --version
echo ""
mkdir -p "$LOG_DIR"

# Run QEMU locally with Cocoa display or nographic mode
# 
# Output Stream Routing (from QEMU-OUTPUT-AND-DEBUGGING.md):
#   - Kernel UART (PL011) → stdout (via -serial stdio)
#   - QEMU errors → stderr
#   - QEMU debug fprintf → stderr
#
# Serial Configuration:
#   -serial stdio: Direct connection (UART → stdout)
#     * Kernel output appears directly in terminal
#     * Simple and reliable for bare-metal kernels
#     * Note: mon:stdio allows monitor access but may not route PL011 correctly
#
# Option explanations:
#   -M virt: Use QEMU's generic AArch64 virtual machine (better device support than raspi4b)
#   -cpu cortex-a72: Use Cortex-A72 CPU (matches Raspberry Pi 4)
#   -m 1G: Allocate 1GB RAM (for kernel development)
#   -kernel: Load bare-metal kernel ELF file (standard QEMU way, simpler than -device loader)
#   -device ramfb: Add ramfb device (RAM framebuffer, configured via fw_cfg)
#   -display cocoa: Use Cocoa display backend (native macOS window) OR -nographic for terminal-only
#   -serial stdio: Redirect UART output directly to stdout
#   -no-reboot: Exit on shutdown instead of rebooting
#   -d guest_errors,unimp,int,fw_cfg,mmio: Enable debug output (guest errors, unimplemented features, interrupts, fw_cfg, mmio)
#   -trace "fw_cfg*": Trace firmware configuration operations (for debugging ramfb)
#   -D: Log file path for QEMU debug output
# Build QEMU command
QEMU_CMD=(
    "$QEMU_BIN"
    -M virt,virtualization=on
    -cpu cortex-a72
    -m 1G
    -kernel "$KERNEL_PATH"
    -device ramfb
    $DISPLAY_MODE
    -serial stdio
    -semihosting
    -semihosting-config enable=on,target=native
    -no-reboot
)

# Display the full command line
echo "QEMU command:"
echo "${QEMU_CMD[@]}"
echo ""

# Set up output redirection if requested
if [ "$SEPARATE_OUTPUT" = "1" ]; then
    KERNEL_LOG="$LOG_DIR/kernel-uart-$$.log"
    QEMU_DEBUG_LOG="$LOG_DIR/qemu-debug-$$.log"
    
    echo "Separating output streams:"
    echo "  Kernel UART → $KERNEL_LOG"
    echo "  QEMU debug → $QEMU_DEBUG_LOG"
    echo ""
    
    # Execute QEMU with separated output
    # Kernel UART (stdout) → kernel log (also shown in terminal via tee)
    # QEMU debug (stderr) → QEMU debug log (also shown in terminal via tee)
    # Note: This uses process substitution which works in bash
    "${QEMU_CMD[@]}" < /dev/null \
        2> >(tee "$QEMU_DEBUG_LOG" >&2) \
        | tee "$KERNEL_LOG"
    
    echo ""
    echo "Output logs saved:"
    echo "  Kernel UART: $KERNEL_LOG"
    echo "  QEMU debug: $QEMU_DEBUG_LOG"
else
    # Execute QEMU normally (output mixed in terminal)
    # All output (kernel UART + QEMU debug) appears together
    "${QEMU_CMD[@]}"
fi



